<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>Sudoku Judge</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 24px; }
    textarea { width: 100%; height: 260px; }
    pre { background: #f5f5f5; padding: 12px; overflow: auto; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    .badge { display:inline-block; padding:2px 8px; border-radius:10px; font-size:12px; background:#eee; }
    .card { border: 1px solid #ddd; border-radius: 10px; padding: 12px; background: #fff; }
    code { background:#f5f5f5; padding:2px 6px; border-radius:6px; }
  </style>
</head>
<body>
  <h1>Sudoku Judge (C++ only)</h1>
  
  <div style="margin-bottom: 16px;">
    <a href="/leaderboard.html" style="padding: 8px 16px; font-size: 14px; cursor: pointer; background: #007bff; color: white; border: none; border-radius: 4px; text-decoration: none; display: inline-block;">랭킹보드</a>
  </div>

  <!-- 문제는 1개 고정 -->
  <input type="hidden" id="problemId" value="1" />

  <div style="margin-bottom:12px;">
    <label>유저명: <input id="userName" placeholder="이름" /></label>
    <label style="margin-left:8px;">전화번호: <input id="phone" placeholder="010-1234-5678" /></label>
    <span class="badge">문제: 스도쿠 풀기 (고정)</span>
  </div>

  <div class="card">
    <h2 style="margin-top:0;">문제: 스도쿠 풀기</h2>
    <p>
      9×9 스도쿠가 주어진다. <code>0</code>은 빈 칸을 의미한다.<br/>
      빈 칸을 모두 채운 뒤 완성된 스도쿠를 반환하라.
    </p>

    <h3>입력</h3>
    <p>9줄에 걸쳐 각 줄에 9개의 숫자가 주어진다. (0은 빈 칸)</p>

    <h3>출력(반환)</h3>
    <p>
      사용자는 <code>Grid solveSudoku(const Grid& input)</code> 함수에서<br/>
      완성된 9×9 스도쿠(<code>1~9</code>)를 <b>반환</b>해야 한다.<br/>
      (입력에서 0이 아닌 칸은 바꾸면 안 됨)
    </p>
  </div>

  <div class="row" style="margin-top:16px;">
    <div>
      <h3>코드</h3>
      <textarea id="code"></textarea>
      <button id="submit">제출</button>
    </div>
    <div>
      <h3>결과</h3>
      <pre id="result">(result)</pre>
    </div>
  </div>

  <h3 style="margin-top:18px;">내 제출 기록</h3>
  <button id="loadSubs">기록 새로고침</button>
  <pre id="subs">(submissions)</pre>

<script>
const FIXED_PROBLEM_ID = 1;

// ✅ 함수 골격만 보여주기 (include/typedef 없음)
const defaultCode = `
// 이 함수만 구현하세요.
// input: 0은 빈 칸인 스도쿠(9x9)
// return: 완성된 스도쿠(9x9, 1~9) 를 반환
//
// 주의:
// - input에서 0이 아닌 칸은 절대 바꾸면 안 됩니다.
// - 출력(stdout)은 채점에 사용되지 않습니다. (반환값만 검증)

Grid solveSudoku(const Grid& input) {
    Grid out = input;
    // TODO: out을 완성해서 반환
    return out;
}
`;

document.getElementById('code').value = defaultCode;

function getUserInfo() {
  return {
    userName: document.getElementById('userName').value.trim(),
    phone: document.getElementById('phone').value.trim()
  };
}

async function loadSubs() {
  const { userName, phone } = getUserInfo();
  const box = document.getElementById('subs');

  if (!userName || !phone) {
    box.textContent = '유저명과 전화번호를 입력하세요.';
    return;
  }

  box.textContent = 'loading...';

  const r = await fetch(
    `/api/submissions?userName=${encodeURIComponent(userName)}&phone=${encodeURIComponent(phone)}&problemId=${FIXED_PROBLEM_ID}`
  );
  let data = await r.json();

  if (!Array.isArray(data) || data.length === 0) {
    box.textContent = '제출 기록이 없습니다.';
    return;
  }

  // 최신 제출부터 정렬
  data.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

  let lines = [];
  for (let i = 0; i < data.length; i++) {
    const sub = data[i];
    const order = data.length - i; // 최신이 마지막 번호 (예: 34회), 오래된 것이 1회

    const status = sub.status || 'UNKNOWN';
    const okText = (status === 'AC') ? '성공' : '실패';
    const timeText = (sub.exec_time_ms != null) ? `${sub.exec_time_ms} ms` : '-';
    const memText  = (sub.memory_kb != null) ? `${sub.memory_kb} KB` : '-';

    // ✅ "몇번째 제출 / 성공여부 / 시간 / 메모리"만
    lines.push(`${order}회 제출 | ${okText} | ${timeText} | ${memText}`);
  }

  box.textContent = lines.join('\n');
}

document.getElementById('submit').onclick = async () => {
  const { userName, phone } = getUserInfo();
  const code = document.getElementById('code').value;
  const out = document.getElementById('result');

  if (!userName || !phone) {
    alert('유저명과 전화번호를 입력하세요.');
    return;
  }

  out.textContent = 'submitting...';

  let data;
  try {
    const r = await fetch('/api/submit', {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({
        userName,
        phone,
        problemId: FIXED_PROBLEM_ID,
        code
      })
    });

    const text = await r.text();
    if (!r.ok) {
      throw new Error(`HTTP ${r.status} ${r.statusText || ''} - ${text.slice(0, 200)}`);
    }
    try {
      data = JSON.parse(text);
    } catch (e) {
      throw new Error('응답을 JSON으로 파싱할 수 없습니다.');
    }
  } catch (err) {
    out.textContent = `요청 실패: ${err}`;
    return;
  }

  const status = data.status || 'UNKNOWN';
  const okText = (status === 'AC') ? '성공' : '실패';
  // totalExecTimeMs (실제 실행 시간 합계) 우선 사용, 없으면 execTimeMs 사용
  const displayTime = (data.totalExecTimeMs != null && data.totalExecTimeMs > 0) ? data.totalExecTimeMs : data.execTimeMs;
  const timeText = (displayTime != null) ? `${displayTime} ms` : '-';
  const memText  = (data.memoryKb != null) ? `${data.memoryKb} KB` : '-';
  const progressText = (data.processedCases != null && data.totalCases != null)
    ? `${data.processedCases} / ${data.totalCases}`
    : '-';
  const stderrText = data.lastStderr ? `\nstderr (마지막 케이스):\n${data.lastStderr}` : '';

  // ✅ 결과창: 성공/시간/메모리만
  out.textContent =
    `성공 여부: ${okText}\n` +
    `경과 시간: ${timeText}\n` +
    `메모리: ${memText}\n` +
    `진행 상황: ${progressText}` +
    stderrText;

  await loadSubs();
};

document.getElementById('loadSubs').onclick = loadSubs;

// 페이지 로드시 제출 기록만 불러오기
loadSubs();
</script>
</body>
</html>
